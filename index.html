<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–ü–æ–¥–∑–µ–º–µ–ª—å–µ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50, #1a1a2e);
            color: #ecf0f1;
            margin: 0;
            padding: 12px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: start;
        }
    
        .container {
            background: rgba(44, 62, 80, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
    
        h1 {
            color: #3498db;
            margin-bottom: 20px;
            font-size: 22px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
    
        .coordinates {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
    
        .coord-input {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    
        .coord-input label {
            margin-bottom: 6px;
            color: #3498db;
            font-weight: bold;
            font-size: 14px;
        }
    
        .coord-input input {
            width: 70px;
            padding: 8px;
            border: 2px solid #3498db;
            border-radius: 8px;
            background: rgba(52, 73, 94, 0.8);
            color: white;
            font-size: 16px;
            text-align: center;
        }
    
        .coord-input input:focus {
            outline: none;
            border-color: #f1c40f;
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.3);
        }
    
        .result {
            background: rgba(52, 73, 94, 0.8);
            border: 2px solid #3498db;
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.3s ease;
        }
    
        .location-name {
            font-size: 20px;
            font-weight: bold;
            color: #f1c40f;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
    
        .location-description {
            font-size: 14px;
            color: #bdc3c7;
            line-height: 1.4;
        }

        .type-badge {
            margin: 10px auto;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: bold;
            display: inline-block;
        }

        /* –¶–≤–µ—Ç–∞ —Ç–∏–ø–æ–≤ */
        .boss { background: #ff3333; }
        .icy { background: #7fdbff; color: #000; }
        .cave { background: #8b4513; }
        .dungeon { background: #555; }
        .rogue { background: #8a2be2; color: white; }
        .cellular { background: #32cd32; color: #000; }
        .arena { background: #ff8c00; }

        /* === –ö–û–ù–¢–ï–ô–ù–ï–† –ö–ê–†–¢–´ === */
        .map-container {
            width: 100%;
            max-width: 450px;
            height: 450px;
            margin: 15px auto;
            overflow: auto;
            border: 2px solid #3498db;
            border-radius: 8px;
            background: #0f0f1a;
            -webkit-overflow-scrolling: touch; /* –ø–ª–∞–≤–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –Ω–∞ iOS */
        }

        /* === –°–ï–¢–ö–ê 50√ó50 === */
        .map {
            display: grid;
            grid-template-columns: repeat(50, 9px);
            grid-template-rows: repeat(50, 9px);
            width: 450px;
            height: 450px;
            gap: 0;
            padding: 0;
            margin: 0;
        }

        /* === –Ø–ß–ï–ô–ö–ê –¢–ê–ô–õ–ê === */
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;           /* —É–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä —ç–º–æ–¥–∑–∏ */
            line-height: 1;
            padding: 0;
            margin: 0;
            width: 9px;           /* –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –ø–æ–¥ —Å–∏–º–≤–æ–ª */
            height: 9px;
            box-sizing: border-box;
            /* –£–±–∏—Ä–∞–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã */
            border: none;
            outline: none;
        }

        .generate-btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }
    
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.6);
            background: linear-gradient(45deg, #3ca0db, #2c8bc9);
        }
    
        .info {
            margin-top: 15px;
            font-size: 12px;
            color: #7f8c8d;
        }
    
        .seed-info {
            margin-top: 8px;
            font-size: 11px;
            color: #95a5a6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÆ –ü–æ–¥–∑–µ–º–µ–ª—å–µ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º</h1>
        
        <div class="coordinates">
            <div class="coord-input">
                <label for="coordX">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ X</label>
                <input type="number" id="coordX" value="1" min="-1000" max="1000">
            </div>
            <div class="coord-input">
                <label for="coordY">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ Y</label>
                <input type="number" id="coordY" value="1" min="-1000" max="1000">
            </div>
        </div>
        
        <div class="result">
            <div class="location-name" id="locationName">–ù–∞–∂–º–∏—Ç–µ "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å"</div>
            <div class="location-description" id="locationDescription"></div>
            <div class="type-badge" id="typeBadge">‚Äî</div>
        </div>

        <div class="map-container">
            <div class="map" id="map"></div>
        </div>
        
        <button class="generate-btn" onclick="generateLocation()">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
        <div class="info">–û–¥–∏–Ω–∞–∫–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã ‚Üí –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏ –∫–∞—Ä—Ç–∞</div>
        <div class="seed-info" id="seedInfo"></div>
    </div>

    <script>
        // === –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏–π (—Å–æ–∫—Ä–∞—â–µ–Ω–∞ –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏) ===
        const NAME_COMPONENTS = {
            themes: {
                dark: { prefixes: ['–ù–µ–∫','–ú–æ—Ä','–¢–∞—Ä'], roots: ['–∞–ª–∏','—É—Å'], suffixes: ['—Ç—É—Å','–≥–∞–Ω'] },
                light: { prefixes: ['–õ—É–º','–°–∏–ª'], roots: ['–∏–º–∞','–∞–Ω'], suffixes: ['—Ç–∞–ª','–º–∏—Ä'] },
                underground: { prefixes: ['–ì–∞–Ω','–ì—Ä–æ'], roots: ['–æ–≥','–∞—Ä'], suffixes: ['–∑–∞—Ä','—Ä–æ–Ω'] },
                ancient: { prefixes: ['–ê–∫–∞','–≠–ª–æ'], roots: ['—Ç—É–Ω','–º–∞—Ä'], suffixes: ['–¥–æ—Ä','–º–∏—Ä'] }
            },
            locationTypes: {
                dungeon: ['–ü–æ–¥–∑–µ–º–µ–ª—å—è', '–¢–µ–º–Ω—ã–µ –∫–∞—Ç–∞–∫–æ–º–±—ã'],
                cave: ['–ü–µ—â–µ—Ä—ã', '–ì–ª—É–±–∏–Ω–Ω—ã–µ –ø–µ—â–µ—Ä—ã'],
                icy: ['–õ–µ–¥—è–Ω—ã–µ –ª–∞–±–∏—Ä–∏–Ω—Ç—ã', '–•—Ä—É—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ—Ä–∏–¥–æ—Ä—ã'],
                rogue: ['–ó–∞–±—Ä–æ—à–µ–Ω–Ω—ã–µ —Ä—É–∏–Ω—ã', '–î—Ä–µ–≤–Ω–∏–µ —Ä—É–∏–Ω—ã'],
                cellular: ['–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–µ –ø–µ—â–µ—Ä—ã', '–ñ–∏–≤—ã–µ –ø–æ–ª–æ—Å—Ç–∏'],
                arena: ['–ê—Ä–µ–Ω—ã', '–ë–æ–µ–≤—ã–µ –∫—Ä—É–≥–∏'],
                boss: ['–õ–æ–≥–æ–≤–æ', '–¢—Ä–æ–Ω–Ω—ã–π –∑–∞–ª']
            },
            extras: ['–º–∞','–ª–∏','—Ç–∞','—Å—É']
        };

        // === –¢–∏–ø—ã –ø–æ–¥–∑–µ–º–µ–ª–∏–π ===
        const DUNGEON_TYPES = [
            { name: 'dungeon', weight: 14, emoji: 'üß±', floor: '‚¨ú' },
            { name: 'cave', weight: 14, emoji: 'üï≥Ô∏è', floor: 'üü§' },
            { name: 'icy', weight: 14, emoji: '‚ùÑÔ∏è', floor: 'üßä' },
            { name: 'rogue', weight: 14, emoji: 'üó°Ô∏è', floor: '‚¨õ' },
            { name: 'cellular', weight: 14, emoji: 'üß´', floor: 'üü£' },
            { name: 'arena', weight: 14, emoji: 'üé™', floor: 'üü•' },
            { name: 'boss', weight: 2, emoji: 'üëë', floor: 'üî•' }
        ];
        const TOTAL_WEIGHT = DUNGEON_TYPES.reduce((sum, t) => sum + t.weight, 0);

        // === –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä ===
        class SeededRandom {
            constructor(seed) {
                this.seed = Math.abs(seed) || 1;
            }
            next() {
                this.seed = (this.seed * 16807) % 2147483647;
                return (this.seed - 1) / 2147483646;
            }
            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }
            int(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }
        }

        function createSeed(x, y) {
            let seed = 0;
            seed = (seed * 31 + x) | 0;
            seed = (seed * 31 + y) | 0;
            seed = (seed ^ (seed >>> 13)) | 0;
            seed = (seed * 0x5bd1e995) | 0;
            seed = (seed ^ (seed >>> 15)) | 0;
            return (Math.abs(seed) % 2147483647) || 1;
        }

        function selectDungeonType(rand) {
            const r = rand.next();
            let cumulative = 0;
            for (const type of DUNGEON_TYPES) {
                cumulative += type.weight / TOTAL_WEIGHT;
                if (r < cumulative) {
                    return type;
                }
            }
            return DUNGEON_TYPES[DUNGEON_TYPES.length - 1];
        }

        // === –ì–ï–ù–ï–†–ê–¢–û–† 1: –ö–æ–º–Ω–∞—Ç—ã + –∫–æ—Ä–∏–¥–æ—Ä—ã (–¥–ª—è dungeon, rogue, icy) ===
        function generateRoomCorridorMap(rand, size = 50) {
            const grid = Array(size).fill().map(() => Array(size).fill('wall'));
            const rooms = [];

            const roomCount = rand.int(4, 8);
            for (let i = 0; i < roomCount; i++) {
                const w = rand.int(3, 6);
                const h = rand.int(3, 6);
                const x = rand.int(1, size - w - 1);
                const y = rand.int(1, size - h - 1);

                let overlaps = false;
                for (const r of rooms) {
                    if (x < r.x + r.w && x + w > r.x && y < r.y + r.h && y + h > r.y) {
                        overlaps = true;
                        break;
                    }
                }
                if (overlaps) continue;

                // –í—ã—Ä–µ–∑–∞–µ–º –∫–æ–º–Ω–∞—Ç—É
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        grid[y + dy][x + dx] = 'floor';
                    }
                }
                rooms.push({x, y, w, h});
            }

            // –°–æ–µ–¥–∏–Ω—è–µ–º –∫–æ—Ä–∏–¥–æ—Ä–∞–º–∏
            for (let i = 1; i < rooms.length; i++) {
                const r1 = rooms[i - 1];
                const r2 = rooms[i];
                const cx1 = r1.x + Math.floor(r1.w / 2);
                const cy1 = r1.y + Math.floor(r1.h / 2);
                const cx2 = r2.x + Math.floor(r2.w / 2);
                const cy2 = r2.y + Math.floor(r2.h / 2);

                // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
                const stepX = cx1 < cx2 ? 1 : -1;
                for (let x = cx1; x !== cx2 + stepX; x += stepX) {
                    if (x >= 0 && x < size) grid[cy1][x] = 'floor';
                }
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
                const stepY = cy1 < cy2 ? 1 : -1;
                for (let y = cy1; y !== cy2 + stepY; y += stepY) {
                    if (y >= 0 && y < size) grid[y][cx2] = 'floor';
                }
            }

            // –¶–µ–Ω—Ç—Ä ‚Äî –≤—Å–µ–≥–¥–∞ –ø—Ä–æ—Ö–æ–¥
            grid[Math.floor(size/2)][Math.floor(size/2)] = 'floor';

            return grid.flat();
        }

        // === –ì–ï–ù–ï–†–ê–¢–û–† 2: –ö–ª–µ—Ç–æ—á–Ω—ã–π –∞–≤—Ç–æ–º–∞—Ç (–¥–ª—è cave, cellular) ===
        function generateCellularMap(rand, size = 50) {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
            let grid = Array(size).fill().map(() => Array(size).fill('wall'));
            const fillChance = 0.45;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (rand.next() < fillChance) {
                        grid[y][x] = 'floor';
                    }
                }
            }

            // 4 –∏—Ç–µ—Ä–∞—Ü–∏–∏ –∫–ª–µ—Ç–æ—á–Ω–æ–≥–æ –∞–≤—Ç–æ–º–∞—Ç–∞
            for (let iter = 0; iter < 4; iter++) {
                const newGrid = Array(size).fill().map(() => Array(size).fill('wall'));
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (x === 0 || x === size - 1 || y === 0 || y === size - 1) {
                            newGrid[y][x] = 'wall';
                            continue;
                        }
                        let wallCount = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                if (grid[y + dy][x + dx] === 'wall') wallCount++;
                            }
                        }
                        if (wallCount >= 5) {
                            newGrid[y][x] = 'wall';
                        } else {
                            newGrid[y][x] = 'floor';
                        }
                    }
                }
                grid = newGrid;
            }

            // –¶–µ–Ω—Ç—Ä ‚Äî –ø—Ä–æ—Ö–æ–¥
            grid[Math.floor(size/2)][Math.floor(size/2)] = 'floor';

            return grid.flat();
        }

        // === –ì–ï–ù–ï–†–ê–¢–û–† 3: –ë–æ–ª—å—à–∞—è –∫–æ–º–Ω–∞—Ç–∞ (arena, boss) ===
        function generateArenaMap(rand, size = 50) {
            const grid = Array(size).fill().map(() => Array(size).fill('wall'));

            // –û—Å–Ω–æ–≤–Ω–∞—è –∞—Ä–µ–Ω–∞: –ø–æ—á—Ç–∏ –≤–µ—Å—å —Ü–µ–Ω—Ç—Ä
            const margin = rand.int(1, 2);
            for (let y = margin; y < size - margin; y++) {
                for (let x = margin; x < size - margin; x++) {
                    grid[y][x] = 'floor';
                }
            }

            // –î–æ–±–∞–≤–∏–º –Ω–µ–º–Ω–æ–≥–æ –∫–æ–ª–æ–Ω–Ω (–¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è)
            const colCount = rand.int(0, 6);
            for (let i = 0; i < colCount; i++) {
                const cx = rand.int(margin + 1, size - margin - 2);
                const cy = rand.int(margin + 1, size - margin - 2);
                // –ù–µ —Ç—Ä–æ–≥–∞–µ–º —Ü–µ–Ω—Ç—Ä
                if (Math.abs(cx - size/2) < 2 && Math.abs(cy - size/2) < 2) continue;
                grid[cy][cx] = 'wall';
            }

            return grid.flat();
        }

        // === –ì–ª–∞–≤–Ω—ã–π –¥–∏—Å–ø–µ—Ç—á–µ—Ä –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞—Ä—Ç—ã ===
        function generateMap(rand, type, size = 50) {
            let rawMap; // –º–∞—Å—Å–∏–≤ –∏–∑ 'wall' / 'floor'

            if (['dungeon', 'rogue', 'icy'].includes(type.name)) {
                rawMap = generateRoomCorridorMap(rand, size);
            } else if (['cave', 'cellular'].includes(type.name)) {
                rawMap = generateCellularMap(rand, size);
            } else if (['arena', 'boss'].includes(type.name)) {
                rawMap = generateArenaMap(rand, size);
            } else {
                rawMap = Array(size * size).fill('floor'); // fallback
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —ç–º–æ–¥–∑–∏
            return rawMap.map(cell => 
                cell === 'wall' ? type.emoji : type.floor
            );
        }

        // === –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫–∞—Ä—Ç—ã ===
        function renderMap(cells) {
            const mapEl = document.getElementById('map');
            mapEl.innerHTML = '';
            cells.forEach(cell => {
                const div = document.createElement('div');
                div.className = 'cell';
                div.textContent = cell;
                mapEl.appendChild(div);
            });
        }

        // === –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞–∑–≤–∞–Ω–∏—è ===
        function generateNameAndDesc(rand, typeKey) {
            const themeKeys = Object.keys(NAME_COMPONENTS.themes);
            const theme = NAME_COMPONENTS.themes[rand.choice(themeKeys)];

            let name = rand.choice(theme.prefixes);
            if (rand.next() > 0.5) name += rand.choice(theme.roots);
            if (rand.next() > 0.5) name += rand.choice(NAME_COMPONENTS.extras);
            name += rand.choice(theme.suffixes);
            name = name.charAt(0).toUpperCase() + name.slice(1);

            const locType = rand.choice(NAME_COMPONENTS.locationTypes[typeKey] || ['–õ–æ–∫–∞—Ü–∏—è']);
            const desc = `${rand.choice(['–∑–∞–±—ã—Ç–∞—è', '–ø—Ä–æ–∫–ª—è—Ç–∞—è', '–¥—Ä–µ–≤–Ω—è—è'])}, ${rand.choice(['–æ—Å–≤–µ—â—ë–Ω–Ω–∞—è —Ç—É—Å–∫–ª—ã–º —Å–≤–µ—Ç–æ–º', '–ø–æ–ª–Ω–∞—è —ç—Ö–∞', '–æ–∫—É—Ç–∞–Ω–Ω–∞—è —Ç—É–º–∞–Ω–æ–º'])}`;

            return { name: `${locType} ${name}`, desc };
        }

        // === –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è ===
        function generateLocation() {
            const x = parseInt(document.getElementById('coordX').value) || 0;
            const y = parseInt(document.getElementById('coordY').value) || 0;
            const seed = createSeed(x, y);

            // –û—Ç–¥–µ–ª—å–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã –∏–∑ –æ–¥–Ω–æ–≥–æ seed'–∞
            const typeRand = new SeededRandom(seed);
            const dungeonType = selectDungeonType(typeRand);

            const nameRand = new SeededRandom(seed);
            const { name, desc } = generateNameAndDesc(nameRand, dungeonType.name);

            const mapRand = new SeededRandom(seed);
            const map = generateMap(mapRand, dungeonType, 50);

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
            document.getElementById('locationName').textContent = name;
            document.getElementById('locationDescription').textContent = desc;
            const badge = document.getElementById('typeBadge');
            badge.textContent = dungeonType.name;
            badge.className = 'type-badge ' + dungeonType.name;

            renderMap(map);
            document.getElementById('seedInfo').textContent = `–°–µ–º—è: ${seed} (X: ${x}, Y: ${y})`;
        }

        window.onload = generateLocation;
        document.getElementById('coordX').addEventListener('keypress', e => { if (e.key === 'Enter') generateLocation(); });
        document.getElementById('coordY').addEventListener('keypress', e => { if (e.key === 'Enter') generateLocation(); });
    </script>
</body>
</html>
